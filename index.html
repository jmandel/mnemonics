<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mnemonic Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: #1a1a1a;
      border-bottom: 1px solid #333;
      padding: 0.75rem;
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-shrink: 0;
    }

    .header input {
      flex: 1;
      max-width: 300px;
      padding: 0.5rem 1rem;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      color: white;
      font-size: 1.1rem;
      font-family: monospace;
    }

    .header input:focus {
      outline: none;
      border-color: #4a9eff;
      box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.2);
    }

    .stats {
      font-size: 0.9rem;
      color: #888;
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .stat-value {
      color: #4a9eff;
      font-weight: 600;
    }

    /* Main container */
    .main {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 1rem;
      background: #0f0f0f;
    }

    /* Partition list */
    .partitions {
      display: flex;
      flex-direction: column;
      gap: 2px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }


      gap: 0.75rem;
      transition: all 0.15s ease;
      cursor: pointer;
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
    }

    .partition:hover {
      background: #222;
      border-color: #3a3a3a;
      transform: translateX(2px);
    }

    .partition.selected {
      background: #1a2332;
      border-color: #2a4a6a;
      box-shadow: 0 0 0 1px rgba(74, 158, 255, 0.3);
    }

    /* Quality indicator */
    .quality {
      width: 4px;
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
      background: linear-gradient(to bottom, 
        var(--quality-color) 0%, 
        var(--quality-color) var(--quality-percent), 
        transparent var(--quality-percent));
    }

    /* Partition segments */
    .segments {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      line-height: 1.4;
      min-width: 0;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .segment {
      display: flex;
      align-items: baseline;
      gap: 0.4rem;
    }

    .digits {
      font-family: monospace;
      font-size: 0.85rem;
      color: #666;
      font-weight: 600;
    }

    .words {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.3rem;
      align-items: baseline;
      white-space: nowrap;
    }

    .word {
      transition: all 0.15s ease;
    }

    /* Word frequency coloring */
    .word-rare { color: #555; font-size: 0.85rem; }
    .word-uncommon { color: #888; font-size: 0.9rem; }
    .word-common { color: #bbb; font-size: 0.95rem; }
    .word-frequent { color: #fff; font-size: 1rem; font-weight: 500; }

    .partition:hover .word-frequent {
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }

    .plus {
      color: #444;
      font-size: 1rem;
      padding: 0 0.2rem;
    }

    /* Metrics */
    .metrics {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      flex-shrink: 0;
    }

    .metric {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.8rem;
      color: #666;
    }

    .metric-value {
      color: #999;
      font-weight: 600;
    }

    /* Loading and empty states */
    .loading, .empty {
      text-align: center;
      padding: 3rem;
      color: #666;
    }

    .loading::after {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      margin-left: 0.5rem;
      border: 2px solid #444;
      border-radius: 50%;
      border-top-color: #4a9eff;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Scrollbar styling */
    .main::-webkit-scrollbar {
      width: 10px;
    }

    .main::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .main::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 5px;
    }

    .main::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    /* Help tooltip */
    .help {
      position: relative;
      cursor: help;
      color: #666;
      font-size: 0.9rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid #333;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .help:hover {
      color: #999;
      border-color: #444;
    }

    .tooltip {
      position: absolute;
      bottom: 100%;
      right: 0;
      margin-bottom: 0.5rem;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 1rem;
      width: 300px;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .help:hover .tooltip {
      display: block;
    }

    .tooltip h3 {
      margin-bottom: 0.5rem;
      color: #4a9eff;
    }

    .tooltip p {
      font-size: 0.85rem;
      line-height: 1.5;
      color: #ccc;
      margin-bottom: 0.5rem;
    }

    /* Filter controls */
    .filters {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .filter-btn {
      padding: 0.25rem 0.75rem;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #999;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .filter-btn:hover {
      background: #333;
      color: #ccc;
    }

    .filter-btn.active {
      background: #2a4a6a;
      border-color: #4a9eff;
      color: #4a9eff;
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .header {
        flex-wrap: wrap;
        gap: 0.5rem;
      .help {
        display: none;
      .filter-btn {
        padding: 0.2rem 0.5rem;
        font-size: 0.8rem;
      }
      
      .header input {
        flex: 1 1 100%;
        max-width: none;
      }
      
      .filters {
        flex: 1 1 auto;
      }
      
      .stats {
        flex: 1 1 auto;
        justify-content: flex-end;
      }
      
      .partition {
        padding: 0.4rem 0.6rem;
        /* Ensure horizontal scrolling works on mobile */
        max-width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .segments {
        font-size: 0.85rem;
        padding-right: 1rem; /* Give some breathing room for scrolling */
      }
      
      .metrics {
        flex-shrink: 0;
        padding-left: 0.5rem;
        border-left: 1px solid #333;
        margin-left: 0.5rem;
      }
      
      /* Show scroll hint on mobile */
      .partition::after {
        content: '';
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 30px;
        background: linear-gradient(to right, transparent, rgba(26, 26, 26, 0.95));
        pointer-events: none;
      }
      
      .help {
        display: none;
      }
      
      .filter-btn {
        padding: 0.2rem 0.5rem;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <input type="text" id="numInput" placeholder="Enter number..." autofocus>
    
    <div class="filters">
      <button class="filter-btn active" data-sort="quality">Best First</button>
      <button class="filter-btn" data-sort="length">Shortest First</button>
      <button class="filter-btn" data-sort="balanced">Most Balanced</button>
    </div>
    
    <div class="stats">
      <div class="stat">
        <span>Partitions:</span>
        <span class="stat-value" id="partitionCount">0</span>
      </div>
      <div class="stat">
        <span>Valid:</span>
        <span class="stat-value" id="validCount">0</span>
      </div>
    </div>
    
    <div class="help">
      ?
      <div class="tooltip">
        <h3>Mnemonic System</h3>
        <p>Numbers → Consonants → Words</p>
        <p>0=S/Z, 1=T/D, 2=N, 3=M, 4=R, 5=L, 6=CH/SH, 7=K/G, 8=F/V, 9=P/B</p>
        <p>Brighter words are more common. Click any partition to copy.</p>
      </div>
    </div>
  </header>

  <main class="main" id="results">
    <div class="empty">
      Enter a number to explore mnemonic possibilities
    </div>
  </main>

  <script type="module">
    // Dictionary and state
    let dict = {};
    let currentPartitions = [];
    let currentSort = 'quality';
    
    // Load dictionary
    async function loadDictionary() {
      const response = await fetch("cmudict.json");
      return await response.json();
    }
    
    // Frequency percentiles for word classification
    let freqPercentiles = {};
    
    async function computeFrequencyPercentiles(dict) {
      const allFreqs = [];
      for (const key in dict) {
        for (const entry of dict[key]) {
          allFreqs.push(entry.freq);
        }
      }
      allFreqs.sort((a, b) => a - b);
      
      return {
        p25: allFreqs[Math.floor(allFreqs.length * 0.25)],
        p50: allFreqs[Math.floor(allFreqs.length * 0.50)],
        p75: allFreqs[Math.floor(allFreqs.length * 0.75)],
        p90: allFreqs[Math.floor(allFreqs.length * 0.90)],
        max: allFreqs[allFreqs.length - 1]
      };
    }
    
    // Generate all partitions using balanced approach
    function generatePartitions(numStr) {
      const items = numStr.split('');
      const n = items.length;
      const totalPartitions = Math.pow(2, n - 1);
      const partitions = [];
      
      for (let j = 0; j < totalPartitions; j++) {
        const partition = nthPartitionBalanced(j, items);
        partitions.push(partition.map(seg => seg.join('')));
      }
      
      return partitions;
    }
    
    // Helper functions for balanced partition generation
    function nthPartitionBalanced(j, items) {
      const m = items.length;
      const n = m - 1;
      let total = 0;
      let chosenK = null;
      let localRank = null;
      
      for (let k = 0; k <= n; k++) {
        const count = binom(m - 1, k);
        if (j < total + count) {
          chosenK = k;
          localRank = j - total;
          break;
        }
        total += count;
      }
      
      const breakpoints = unrankBalancedForK(chosenK, m, localRank);
      const partition = [];
      let start = 0;
      
      for (let i = 0; i < breakpoints.length; i++) {
        partition.push(items.slice(start, breakpoints[i] + 1));
        start = breakpoints[i] + 1;
      }
      partition.push(items.slice(start));
      return partition;
    }
    
    function unrankBalancedForK(k, m, rank) {
      const s = k + 1;
      const comp = unrankComposition(s, m, rank);
      const breakpoints = [];
      let cum = comp[0] - 1;
      
      if (k >= 1) breakpoints.push(cum);
      for (let i = 1; i < s - 1; i++) {
        cum += comp[i];
        breakpoints.push(cum);
      }
      return breakpoints;
    }
    
    function unrankComposition(s, m, rank) {
      const costMap = dp(1, m, s, m);
      const costs = Object.keys(costMap).map(Number).sort((a, b) => a - b);
      let bucket = null;
      
      for (let c of costs) {
        if (rank < costMap[c]) {
          bucket = c;
          break;
        }
        rank -= costMap[c];
      }
      
      return unrankLex(1, m, s, m, bucket, rank);
    }
    
    function dp(i, R, s, m, memo = {}) {
      const key = i + "," + R;
      if (key in memo) return memo[key];
      
      let result = {};
      if (i > s) {
        if (R === 0) result[0] = 1;
        memo[key] = result;
        return result;
      }
      
      for (let d = 1; d <= R - (s - i); d++) {
        const cost_d = Math.pow(s * d - m, 2);
        const next = dp(i + 1, R - d, s, m, memo);
        for (let costNext in next) {
          const totalCost = cost_d + Number(costNext);
          result[totalCost] = (result[totalCost] || 0) + next[costNext];
        }
      }
      
      memo[key] = result;
      return result;
    }
    
    function lexCount(i, R, s, m, remCost, memo = {}) {
      const key = i + "," + R + "," + remCost;
      if (key in memo) return memo[key];
      
      let count = 0;
      if (i > s) {
        count = (R === 0 && remCost === 0) ? 1 : 0;
        memo[key] = count;
        return count;
      }
      
      for (let d = 1; d <= R - (s - i); d++) {
        const cost_d = Math.pow(s * d - m, 2);
        if (cost_d > remCost) continue;
        count += lexCount(i + 1, R - d, s, m, remCost - cost_d, memo);
      }
      
      memo[key] = count;
      return count;
    }
    
    function unrankLex(i, R, s, m, remCost, rank) {
      if (i > s) {
        if (R === 0 && remCost === 0) return [];
        else throw new Error("Unranking error");
      }
      
      for (let d = 1; d <= R - (s - i); d++) {
        const cost_d = Math.pow(s * d - m, 2);
        if (cost_d > remCost) continue;
        const count = lexCount(i + 1, R - d, s, m, remCost - cost_d);
        if (rank < count) {
          return [d].concat(unrankLex(i + 1, R - d, s, m, remCost - cost_d, rank));
        } else {
          rank -= count;
        }
      }
      
      throw new Error("Unranking error");
    }
    
    function binom(n, k) {
      if (k < 0 || k > n) return 0;
      let num = 1, den = 1;
      for (let i = 1; i <= k; i++) {
        num *= (n - i + 1);
        den *= i;
      }
      return num / den;
    }
    
    // Process and score partitions
    function processPartitions(numStr) {
      const allPartitions = generatePartitions(numStr);
      const validPartitions = [];
      
      for (const parts of allPartitions) {
        const segments = [];
        let valid = true;
        let totalScore = 0;
        let wordCount = 0;
        
        for (const seg of parts) {
          if (dict[seg]) {
            const words = dict[seg];
            // Take top words by frequency
            const topWords = words
              .sort((a, b) => b.freq - a.freq)
              .slice(0, 8); // Limit display
            
            segments.push({
              digits: seg,
              words: topWords,
              bestFreq: topWords[0]?.freq || 0
            });
            
            totalScore += topWords[0]?.freq || 0;
            wordCount += topWords.length;
          } else {
            valid = false;
            break;
          }
        }
        
        if (valid) {
          // Calculate quality metrics
          const avgScore = totalScore / segments.length;
          const normalizedAvgScore = avgScore / freqPercentiles.max;
          const balance = 1 - (Math.max(...parts.map(p => p.length)) - Math.min(...parts.map(p => p.length))) / numStr.length;
          
          // Heavily weight fewer parts, but penalize if words are too rare
          const partsPenalty = Math.pow(0.7, parts.length - 1); // Exponential penalty for more parts
          const minAcceptableFreq = freqPercentiles.p50; // Words should be at least median frequency
          const freqPenalty = segments.every(s => s.bestFreq >= minAcceptableFreq) ? 1 : 0.5;
          
          validPartitions.push({
            segments,
            score: avgScore,
            balance,
            partCount: parts.length,
            quality: partsPenalty * freqPenalty * (50 + normalizedAvgScore * 50) // Parts count dominates
          });
        }
      }
      
      return validPartitions;
    }
    
    // Classify word frequency
    function getWordClass(freq) {
      if (freq >= freqPercentiles.p90) return 'word-frequent';
      if (freq >= freqPercentiles.p75) return 'word-common';
      if (freq >= freqPercentiles.p50) return 'word-uncommon';
      return 'word-rare';
    }
    
    // Sort partitions
    function sortPartitions(partitions, method) {
      const sorted = [...partitions];
      switch (method) {
        case 'quality':
          return sorted.sort((a, b) => b.quality - a.quality);
        case 'length':
          // Sort by number of parts first, then by quality
          return sorted.sort((a, b) => {
            if (a.partCount !== b.partCount) {
              return a.partCount - b.partCount;
            }
            return b.quality - a.quality;
          });
        case 'balanced':
          return sorted.sort((a, b) => b.balance - a.balance || b.quality - a.quality);
        default:
          return sorted;
      }
    }
    
    // Render all partitions
    function renderPartitions() {
      const container = document.getElementById('results');
      const sorted = sortPartitions(currentPartitions, currentSort);
      
      if (sorted.length === 0) {
        container.innerHTML = '<div class="empty">No valid partitions found</div>';
        return;
      }
      
      const html = sorted.map((partition, idx) => {
        const qualityPercent = Math.min(100, partition.quality); // Cap at 100%
        const qualityColor = `hsl(${120 * qualityPercent / 100}, 70%, 50%)`;
        
        const segmentsHtml = partition.segments.map((seg, i) => `
          <div class="segment">
            <span class="digits">${seg.digits}:</span>
            <div class="words">
              ${seg.words.map(w => 
                `<span class="${getWordClass(w.freq)}">${w.word.trim()}</span>`
              ).join(' ')}
            </div>
          </div>
          ${i < partition.segments.length - 1 ? '<span class="plus">+</span>' : ''}
        `).join('');
        
        return `
          <div class="partition" data-idx="${idx}" 
               style="--quality-color: ${qualityColor}; --quality-percent: ${qualityPercent}%">
            <div class="quality"></div>
            <div class="segments">${segmentsHtml}</div>
            <div class="metrics">
              <div class="metric">
                <span>Score:</span>
                <span class="metric-value">${Math.round(partition.score)}</span>
              </div>
              <div class="metric">
                <span>Parts:</span>
                <span class="metric-value">${partition.partCount}</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = `<div class="partitions">${html}</div>`;
      
      // Update stats
      document.getElementById('validCount').textContent = sorted.length;
    }
    
    // Handle input
    async function handleInput(numStr) {
      const cleaned = numStr.replace(/\D/g, '');
      const totalPartitions = cleaned ? Math.pow(2, cleaned.length - 1) : 0;
      
      document.getElementById('partitionCount').textContent = totalPartitions;
      
      if (!cleaned) {
        currentPartitions = [];
        document.getElementById('results').innerHTML = 
          '<div class="empty">Enter a number to explore mnemonic possibilities</div>';
        document.getElementById('validCount').textContent = '0';
        return;
      }
      
      document.getElementById('results').innerHTML = '<div class="loading">Processing partitions</div>';
      
      // Process asynchronously
      await new Promise(resolve => setTimeout(resolve, 10));
      currentPartitions = processPartitions(cleaned);
      renderPartitions();
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      // Load dictionary
      dict = await loadDictionary();
      freqPercentiles = await computeFrequencyPercentiles(dict);
      
      // Input handler
      const input = document.getElementById('numInput');
      let timeout;
      input.addEventListener('input', (e) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => handleInput(e.target.value), 150);
      });
      
      // Sort buttons
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentSort = btn.dataset.sort;
          renderPartitions();
        });
      });
      
      // Click to copy partition
      let touchStartX = 0;
      document.getElementById('results').addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
      });
      
      document.getElementById('results').addEventListener('click', (e) => {
        const partition = e.target.closest('.partition');
        if (partition) {
          // On mobile, check if this was a tap or a scroll
          if (e.type === 'click' && window.innerWidth <= 768) {
            const touchEndX = e.clientX;
            if (Math.abs(touchEndX - touchStartX) > 10) {
              return; // This was a scroll, not a tap
            }
          }
          
          const idx = parseInt(partition.dataset.idx);
          const data = sortPartitions(currentPartitions, currentSort)[idx];
          const text = data.segments.map(s => 
            `${s.digits}: ${s.words[0].word.trim()}`
          ).join(' + ');
          
          navigator.clipboard.writeText(text);
          
          // Visual feedback
          partition.style.background = '#2a4a3a';
          setTimeout(() => {
            partition.style.background = '';
          }, 200);
        }
      });
    });
  </script>
</body>
</html>
