<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mnemonics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Use a whimsical font inspired by Lewis Carroll -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Alice&display=swap" rel="stylesheet">
  <style>
    /* Adjusted for a denser layout and larger fonts on mobile */
    body {
      background: #fbf6f0; /* new parchment-like background */
      color: #333;
      font-family: 'Alice', serif, Georgia, "Times New Roman", Times, serif;
      margin: 0;
      padding: 0.5rem; /* kept dense padding */
      line-height: 1.4;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 0.75rem; /* reduced gap for more content density */
    }
    h1 {
      text-align: center;
      font-size: 2rem; /* smaller header size */
      margin: 0;
      color: #5d4037;
      text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.15); /* whimsical shadow effect */
    }
    .input-group {
      display: flex;
      flex-direction: column; /* stack the two controls vertically */
      gap: 0.25rem; /* reduced gap for a super dense layout */
      justify-content: center;
      position: sticky;
      top: 0;
      z-index: 1000;
      background: #fbf6f0;
      padding: 0.25rem;
      transition: padding 0.2s, font-size 0.2s; /* smooth transition for compact mode */
    }
    .input-group > div {
      flex: 1 1 auto;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.25rem;
    }
    .input-group label {
      font-size: 0.9rem;
      margin-bottom: 0;
      margin-right: 0.25rem;
      color: #3e2723;
      white-space: nowrap; /* Prevent label text from wrapping */
    }
    .input-group input {
      font-size: 1rem;
      padding: 0.6rem;
      border: 1px solid #5d4037; /* refined vintage border */
      background: #fff;
      color: #3e2723;
      border-radius: 8px; /* more whimsical rounded corners */
      box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
      width: 100%;
      box-sizing: border-box;
    }
    /* Results: page grows longer */
    #results {
      margin-top: 1rem;
    }
    /* Each partition container uses flexbox in column direction */
    .result {
      display: flex;
      flex-direction: column;
      margin-bottom: 0.75rem; /* reduced margin for denser layout */
      padding: 0.5rem; /* reduced padding */
      background: #fff;
      border: 2px dotted #a1887f; /* more delicate dotted border for a whimsical look */
      border-radius: 8px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
      overflow-wrap: break-word;
    }
    .result::before {
      content: "";
      display: block;
      border-top: 2px solid #d7ccc8;
      margin-bottom: 0.5rem; /* reduced margin */
    }
    /* Each segment appears as a full-width row */
    .segment {
      width: 100%;
      padding: 0.25rem;
      font-style: italic;
    }
    /* The plus sign appears on its own line, centered */
    .plus {
      width: 100%;
      text-align: center;
      font-size: 2rem;
      font-weight: bold;
      color: #8d6e63;
      margin: 0.5rem 0;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1); /* subtle hand-drawn effect */
    }
    /* Explanation area styling */
    .explanation {
      border-top: 3px double #8d6e63; /* softer, whimsical tone */
      padding-top: 0.5rem; /* reduced padding for denser layout */
      font-size: 0.95rem;
      line-height: 1.5;
      color: #4e342e;
    }
    .explanation h2 {
      text-align: center;
      font-size: 1.75rem;
      margin-bottom: 0.25rem; /* reduced margin */
      color: #5d4037;
    }
    .mapping-table {
      width: 100%;
      max-width: 600px;
      margin: 0.25rem auto; /* reduced margin */
      border-collapse: collapse;
      font-size: 1rem;
    }
    .mapping-table th, .mapping-table td {
      border: 1px dotted #5d4037; /* playful dotted border */
      padding: 0.5rem;
      text-align: center;
      background: #fce4ec;
    }
    .mapping-table th {
      background: #e3dff8; /* lighter pastel tone for a more whimsical feel */
    }
    /* Mobile styles: Increase font sizes for readability on smaller screens */
    @media (max-width: 600px) {
      body {
        font-size: 1.2rem;
        padding: 0.75rem;
      }
      h1 {
        font-size: 3.5rem;
        margin: 0.2rem 0; /* slight margin for mobile */
      }
      .explanation h2 {
        font-size: 2rem;
      }
      .input-group input {
        font-size: 1.1rem;
        padding: 0.8rem;
      }
      .mapping-table th,
      .mapping-table td {
        font-size: 1.1rem;
        padding: 0.6rem;
      }
    }
    .input-group.compact {
      padding: 0.1rem;
    }
    .input-group.compact input {
      font-size: 0.85rem;
      padding: 0.3rem;
    }
    .input-group.compact label {
      font-size: 0.75rem;
    }
    #minPercentileDisplay {
      display: inline-block;
      width: 4em; /* increased fixed width to accommodate "100%" without jumping */
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Interactive Area -->
    <h1>Mnemonics</h1>
    <div class="input-group">
      <div>
        <label for="numericInput">Num</label>
        <input autofocus type="text" id="numericInput" placeholder="Enter numeric string..." value="">
      </div>
      <div>
        <label for="minPercentileInput">Word Freq</label>
        <input type="range" id="minPercentileInput" min="0" max="100" value="25">
        <span id="minPercentileDisplay">25%</span>
      </div>
    </div>
    <div id="results"></div>
    
    <!-- Explanation Area -->
    <div class="explanation">
      <h2>About the System</h2>
      <p>
        Our system uses a classic mnemonic technique where numbers are transformed into consonant sounds.
        Each digit stands for one or more consonant sounds according to a traditional mapping.
        Vowels and extra letters can then be added freely to form full words, making it easier to remember the digits.
      </p>
      <p>The table below shows the mapping between digits and the consonant sounds they represent:</p>
      <table class="mapping-table">
        <thead>
          <tr>
            <th>Digit</th>
            <th>Consonant Sounds</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>0</td><td>S, Z</td></tr>
          <tr><td>1</td><td>T, D, TH, DH</td></tr>
          <tr><td>2</td><td>N</td></tr>
          <tr><td>3</td><td>M</td></tr>
          <tr><td>4</td><td>R</td></tr>
          <tr><td>5</td><td>L</td></tr>
          <tr><td>6</td><td>CH, JH, SH, ZH</td></tr>
          <tr><td>7</td><td>K, G, NG</td></tr>
          <tr><td>8</td><td>F, V</td></tr>
          <tr><td>9</td><td>P, B</td></tr>
        </tbody>
      </table>
      <p>
        Once you enter your numbers, our generator explores all possible ways to split the sequence.
        It then searches a dictionary for words whose consonant patterns match the digits you provided.
        The slider above lets you filter the results by word frequency, so you can focus on the words that best help you remember.
      </p>
    </div>
  </div>
  
  <script type="module">
    // --- Mnemonic Generator Implementation ---
    // This implementation loads a preprocessed JSON dictionary (cmudict.json)
    // and streams valid partitions using an asynchronous generator.
    
    async function loadDictionary() {
      const response = await fetch("cmudict.json");
      const data = await response.json();
      return data;
    }
    
    // Compute a global sorted array of frequencies from the dictionary.
    async function computeGlobalFrequencies(dict) {
      let freqs = [];
      for (const key in dict) {
        for (const entry of dict[key]) {
          freqs.push(entry.freq);
        }
      }
      freqs.sort((a, b) => a - b); // ascending order
      return freqs;
    }
    
    // Get the value at the given percentile (0-100) from a sorted array.
    function getPercentileValue(sortedArray, percentile) {
      const index = Math.floor((percentile / 100) * (sortedArray.length - 1));
      return sortedArray[index];
    }
    
    /**
     * generatePartitions(numStr, s)
     * Yields all partitions of numStr with exactly s splits.
     * Each partition is an array of substrings.
     */
    function* generatePartitions(numStr, s) {
      const n = numStr.length;
      function* helper(start, count, combination) {
        if (count === 0) {
          yield combination;
          return;
        }
        for (let i = start; i <= n - count; i++) {
          yield* helper(i + 1, count - 1, combination.concat(i));
        }
      }
      for (const combination of helper(1, s, [])) {
        const parts = [];
        let prev = 0;
        for (const index of combination) {
          parts.push(numStr.substring(prev, index));
          prev = index;
        }
        parts.push(numStr.substring(prev));
        yield parts;
      }
    }
    
    /**
     * asyncMnemonicGenerator(numStr, dict, config)
     * An asynchronous generator that yields valid partitions in order.
     * Each yielded partition is an array of objects { digits, words }.
     * Config parameters:
     *   timeSlice: max ms to process per chunk (default 2ms)
     *   maxYields: max iterations per frame (default 5)
     */
    async function* asyncMnemonicGenerator(numStr, dict, config = { timeSlice: 2, maxYields: 5 }) {
      const n = numStr.length;
      let globalCount = 0;
      for (let s = 0; s <= n - 1; s++) {
        for (const parts of generatePartitions(numStr, s)) {
          let valid = true;
          const segmentObjects = [];
          for (const seg of parts) {
            if (dict[seg]) {
              segmentObjects.push({ digits: seg, words: dict[seg] });
            } else {
              valid = false;
              break;
            }
          }
          if (valid) {
            yield segmentObjects;
          }
          globalCount++;
          if (globalCount % config.maxYields === 0) {
            await new Promise(requestAnimationFrame);
          }
        }
      }
    }
    
    // Debounce helper.
    function debounce(func, delay) {
      let timerId;
      return function(...args) {
        clearTimeout(timerId);
        timerId = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    // calibrateConfig: Measure frame times and compute config values.
    async function calibrateConfig() {
      const iterations = 10;
      let times = [];
      let last = performance.now();
      for (let i = 0; i < iterations; i++) {
        await new Promise(requestAnimationFrame);
        const now = performance.now();
        times.push(now - last);
        last = now;
      }
      const avgFrameTime = times.reduce((a, b) => a + b, 0) / times.length;
      const timeSlice = Math.max(1, Math.floor(avgFrameTime * 0.1)); // 10% of average frame time
      const maxYields = 5;
      return { timeSlice, maxYields };
    }
    
    // UI Code
    document.addEventListener("DOMContentLoaded", async () => {
      const numericInput = document.getElementById("numericInput");
      const minPercentileInput = document.getElementById("minPercentileInput");
      const minPercentileDisplay = document.getElementById("minPercentileDisplay");
      const resultsDiv = document.getElementById("results");
    
      const dict = await loadDictionary();
      const globalFreqs = await computeGlobalFrequencies(dict);
      const config = await calibrateConfig();
      console.log("Calibrated config:", config);
    
      // Update input from URL parameter.
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has("n")) numericInput.value = urlParams.get("n");
      if (urlParams.has("minPercentile")) {
        minPercentileInput.value = urlParams.get("minPercentile");
        minPercentileDisplay.textContent = `${urlParams.get("minPercentile")}%`;
      }
    
      let asyncGenerator = null;
    
      function updateUrl() {
        const state = {
          n: numericInput.value.trim(),
          minPercentile: minPercentileInput.value
        };
        const newUrl = window.location.pathname + "?" + new URLSearchParams(state).toString();
        history.replaceState(null, "", newUrl);
      }
    
      function clearResults() {
        resultsDiv.innerHTML = "";
      }
    
      // appendResult: Render a partition with each segment on a clear line,
      // with a big "+" between segments. Skip partition if any segment's filtered list is empty.
      function appendResult(partition, minThreshold) {
        // Check each segment; if any segment's filtered word list is empty, skip this partition.
        for (const segmentObj of partition) {
          const filtered = segmentObj.words.filter(entry => entry.freq >= minThreshold);
          if (filtered.length === 0) return;
        }
        const container = document.createElement("div");
        container.className = "result";
    
        // Use flexbox column layout for the partition.
        container.style.display = "flex";
        container.style.flexDirection = "column";
    
        partition.forEach((segmentObj, idx) => {
          const segDiv = document.createElement("div");
          segDiv.className = "segment";
          const filtered = segmentObj.words.filter(entry => entry.freq >= minThreshold);
          const sorted = filtered.map(entry => entry.freq).sort((a, b) => a - b);
          const idx90 = Math.floor(0.9 * (sorted.length - 1));
          const topThreshold = sorted[idx90];
          const rendered = filtered.map(entry => {
            if (entry.freq >= topThreshold) {
              return `<strong>${entry.word}</strong>`;
            } else {
              return entry.word;
            }
          });
          segDiv.innerHTML = `${segmentObj.digits}: ${rendered.join(", ")}`;
          container.appendChild(segDiv);
          // Insert a plus sign between segments if not the last segment.
          if (idx < partition.length - 1) {
            const plusDiv = document.createElement("div");
            plusDiv.className = "plus";
            plusDiv.textContent = "+";
            // Ensure plusDiv is on its own line and left aligned.
            plusDiv.style.width = "100%";
            plusDiv.style.textAlign = "center";
            container.appendChild(plusDiv);
          }
        });
        // Add an obvious separator after the partition.
        const separator = document.createElement("hr");
        separator.style.borderTop = "2px solid #8d6e63";
        container.appendChild(separator);
        resultsDiv.appendChild(container);
      }
    
      async function loadMore() {
        if (!asyncGenerator) return;
        while (true) {
          const { value, done } = await asyncGenerator.next();
          if (done) break;
          const minPercentile = parseInt(minPercentileInput.value, 10);
          const globalThreshold = getPercentileValue(globalFreqs, minPercentile);
          appendResult(value, globalThreshold);
        }
      }
    
      // Regenerate mid-drag and on input changes.
      minPercentileInput.addEventListener("input", () => {
        minPercentileDisplay.textContent = `${minPercentileInput.value}%`;
        regenerate();
      });
    
      const regenerate = debounce(async () => {
        clearResults();
        updateUrl();
        const numStr = numericInput.value.trim();
        if (!numStr) return;
        asyncGenerator = asyncMnemonicGenerator(numStr, dict, config);
        await loadMore();
      }, 100);
    
      numericInput.addEventListener("input", regenerate);
    
      if (numericInput.value.trim()) {
        updateUrl();
        asyncGenerator = asyncMnemonicGenerator(numericInput.value.trim(), dict, config);
        loadMore();
      }
    
      // Additional code: toggle compact mode for the sticky control area
      const inputGroup = document.querySelector('.input-group');
      function checkSticky() {
          // When the top of inputGroup is at or above 0, add compact class.
          if (inputGroup.getBoundingClientRect().top <= 0) {
              inputGroup.classList.add('compact');
          } else {
              inputGroup.classList.remove('compact');
          }
      }
      window.addEventListener('scroll', checkSticky, { passive: true });
      checkSticky(); // Run an initial check in case page load already places it at top.

      window.addEventListener("scroll", () => {
        if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 20) {
          loadMore();
        }
      });
    });
  </script>
</body>
</html>
